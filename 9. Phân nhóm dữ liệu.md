# 1. Sum Function

Hàm **SUM** trả về tổng giá trị hoặc giá trị riêng biệt. Cú pháp của hàm **SUM** như sau:
```sql
    SUM(DISTINCT cột)
```

Có một số điểm quan trọng bạn nên nhớ khi sử dụng hàm **SUM**:
- Hàm **SUM** bỏ qua các giá trị **NULL**. Nó có nghĩa là các giá trị **NULL** không được xem xét trong tính toán của hàm **SUM**.
- Nếu bạn sử dụng toán tử **DISTINCT**, hàm **SUM** chỉ tính các giá trị của các giá trị riêng biệt. Ví dụ: không có toán tử **DISTINCT**, hàm **SUM** trả về 12 khi tính tổng của 1, 1, 8 và 2. Tuy nhiên, với toán tử **DISTINCT**, hàm SUM sẽ trả về 11 (1 + 8 + 2).
- Nếu bạn sử dụng hàm **SUM** trong mệnh đề **SELECT**, nó sẽ trả về giá trị **NULL** thay vì 0 trong trường hợp câu lệnh **SELECT** không trả về hàng nào.

# 2. Min, Max, Avg Functions

- Hàm **MIN** là một trong các hàm tổng hợp trả về giá trị tối thiểu trong một tập hợp các giá trị. Để tìm giá trị tối thiểu của cột trong một bảng, bạn chuyển cột đó cho hàm **MIN** trong câu lệnh **SELECT**. Kiểu dữ liệu của cột có thể là số, chuỗi hoặc bất kỳ loại so sánh nào.

- Hàm **MAX** là một hàm tổng hợp trả về giá trị tối đa trong một tập hợp các giá trị. Hàm **MAX** rất hữu ích trong nhiều trường hợp. Ví dụ: để tìm những nhân viên có mức lương cao nhất, hoặc tìm những sản phẩm đắt nhất, v.v.

- Hàm **AVG** là một trong những hàm tổng hợp được sử dụng phổ biến nhất trong PostgreSQL. Hàm **AVG** cho phép bạn tính giá trị trung bình của một cột số.

```sql
-- hàm tìm min
    SELECT MIN(cột) FROM bảng;
-- hàm tìm max
    SELECT MAX(cột) FROM bảng;
-- hàm tính avg
    SELECT AVG(cột) FROM bảng;
```

# 3. Group By Clause

Mệnh đề **GROUP BY** chia các hàng được trả về từ câu lệnh **SELECT** thành các nhóm. Đối với mỗi nhóm, bạn có thể áp dụng hàm tổng hợp *(aggregate function)*, ví dụ: **SUM()** để tính tổng các mục hoặc **COUNT()** để lấy số lượng mục trong các nhóm.

Câu lệnh sau minh họa cú pháp của mệnh đề **GROUP BY**:
```sql
    SELECT cột_1, hàm_tổng_hợp(cột_2)
    FROM tên_bảng
    GROUP BY cột_1;
```
Mệnh đề **GROUP BY** phải xuất hiện ngay sau mệnh đề **FROM** hoặc **WHERE**. Tiếp theo là mệnh đề **GROUP BY** là một cột hoặc danh sách các cột được phân tách bằng dấu phẩy. Bên cạnh cột bảng, bạn cũng có thể sử dụng biểu thức với mệnh đề **GROUP BY**.

Mệnh đề **GROUP BY** rất hữu ích khi nó được sử dụng cùng với hàm tổng hợp. Ví dụ: để có được số tiền mà khách hàng đã được trả, bạn sử dụng mệnh đề **GROUP BY** để chia bảng *payment* thành các nhóm; đối với mỗi nhóm, bạn tính tổng số tiền bằng cách sử dụng hàm **SUM()** như được hiển thị trong truy vấn sau:

Cho bảng *payment*
```
payment_id  customer_id staff_id    rental_id   amount
--------------------------------------------------------
1           1           1           76          2.99
2           1           1           573         0.99
3           1           1           1185        5.99
4           1           2           1422        0.99
5           1           2           1476        9.99
6           2           1           320         4.99
7           2           2           7346        24.99
```
```sql
    SELECT customer_id, SUM(amount) AS sum
    FROM payment
    GROUP BY customer_id;
```
```
customer_id  sum
------------------
1            20.95
2            29.98
```
Bạn có thể sử dụng mệnh đề **ORDER BY** với mệnh đề **GROUP BY** để sắp xếp các nhóm:
```sql
    SELECT customer_id, SUM(amount)  AS sum
    FROM payment
    GROUP BY customer_id
    ORDER BY SUM (amount) DESC;
```

Để đếm số lượng giao dịch mà mỗi nhân viên đã xử lý, bạn nhóm bảng payment dựa trên *staff_id* và sử dụng hàm **COUNT()** để lấy số lượng giao dịch như truy vấn sau:
```sql
    SELECT staff_id, COUNT(payment_id)  AS count 
    FROM payment
    GROUP BY staff_id;
```
Cho bảng *payment*
```
payment_id    customer_id    staff_id     rental_id     amount
---------------------------------------------------------------
1             1              1            76            2.99
2             1              1            573           0.99
3             1              1            1185          5.99
4             1              2            1422          0.99
5             1              2            1476          9.99
6             1              1            1725          4.99
7             1              1            2308          4.99
8             1              2            2363          0.99
9             1              1            3284          3.99
10            1              2            4526          5.99
```
Kết quả đầu ra sẽ là
```
staff_id    count
------------------
1           6
2           4
```
Mệnh đề **GROUP BY** sắp xếp kết quả được đặt bởi *staff_id*. Nó giữ tổng số hàng đang chạy và bất cứ khi nào *staff_id* thay đổi, nó sẽ thêm hàng vào tập kết quả được trả về.

# 4. Having Clause

Chúng ta thường sử dụng mệnh đề **HAVING** kết hợp với mệnh đề **GROUP BY** để lọc các hàng nhóm không thỏa mãn một điều kiện cụ thể.

Câu lệnh sau minh họa cú pháp điển hình của mệnh đề **HAVING**:
```sql
    SELECT cột_1, hàm_tổng_hợp(cột_2)
    FROM tên_bảng
    GROUP BY cột_1
    HAVING điều_kiện;
```
Mệnh đề **HAVING** đặt điều kiện cho các hàng nhóm được tạo bởi mệnh đề GROUP BY sau khi mệnh đề **GROUP BY** áp dụng trong khi mệnh đề **WHERE** đặt điều kiện cho các hàng riêng lẻ trước khi áp dụng mệnh đề **GROUP BY**. Đây là sự khác biệt chính giữa các mệnh đề **HAVING** và **WHERE**.

Trong PostgreSQL, bạn có thể sử dụng mệnh đề **HAVING** mà không cần mệnh đề **GROUP BY**. Trong trường hợp này, mệnh đề **HAVING** sẽ biến truy vấn thành một nhóm duy nhất. Ngoài ra, danh sách **SELECT** và mệnh đề **HAVING** chỉ có thể tham chiếu đến các cột từ bên trong các hàm tổng hợp. Loại truy vấn này trả về một hàng đơn nếu điều kiện trong mệnh đề **HAVING** là đúng hoặc bằng 0 nếu nó sai.

Ví dụ về mệnh đề **HAVING** với hàm **SUM()** trong PostgreSQL
Hãy cùng xem bảng *payment* 
```
payment_id  customer_id     staff_id    rental_id   amount
-----------------------------------------------------------
1           1               1           76          2.99
2           2               1           320         4.99
3           2               1           435         1.99
4           3               1           1297        4.99
5           4               1           731         0.99
```

Truy vấn sau đây lấy ra tổng số tiền của mỗi khách hàng bằng cách sử dụng mệnh đề **GROUP BY**:
```sql
    SELECT customer_id, SUM(amount)
    FROM payment
    GROUP BY customer_id;
```
Kết quả là
```
custome_id  sum
1           2.99
2           6.98
3           4.99
4           0.99
```
Bạn có thể áp dụng mệnh đề HAVING để chọn khách hàng duy nhất đã chi hơn 4$ như truy vấn sau:
```sql
    SELECT customer_id, SUM(amount)  AS sum
    FROM payment
    GROUP BY customer_id
    HAVING SUM(amount) > 4;
```
Kết quả là
```
custome_id  sum
2           6.98
3           4.99
```

## Mệnh đề HAVING cùng COUNT
Hãy tham khảo bảng *customer* sau:
```
customer_id     store_id    first_name  last_name   address_id  active
-----------------------------------------------------------------------
1               1           MARY        SMITH       5           1
2               1           PATRICIA    JOHNSON     6           1
3               1           LINDA       WILLIAMS    7           1
4               2           BARBARA     JONES       8           1
5               1           ELIZABETH   BROWN       9           1
```
Truy vấn sau đây trả về số lượng khách hàng trên mỗi cửa hàng:
```sql
    SELECT store_id, COUNT(customer_id)  AS count
    FROM customer
    GROUP BY store_id
```
Đầu ra sẽ là:
```
store_id  count
-----------------
1         4
2         1
```
Bạn có thể sử dụng mệnh đề **HAVING** để chọn cửa hàng có nhiều hơn 3 khách hàng:
```sql
    SELECT store_id, COUNT(customer_id) AS count
    FROM customer
    GROUP BY store_id
    HAVING COUNT(customer_id) > 3;
```
Đầu ra sẽ là
```
store_id    count
-----------------
1           4
```

# 5. Review

## 5.1. Khi sử dụng *HAVING* trong truy vấn, câu nào trong những câu sau đây là *SAI*?

- Khi thực hiện lọc một cột có giá trị số, **HAVING** phải được sử dụng với hàm tổng hợp, ví dụ: **SUM(), COUNT(), AVG()** ... 
==> **ĐÚNG**

- **WHERE** và **HAVING** có thể được sử dụng trong cùng một truy vấn. 
==> **ĐÚNG**

- Sử dụng **HAVING** cùng, và sau, **GROUP BY**. 
==> **ĐÚNG**

- **HAVING** và **WHERE** tạo ra cùng một đầu ra, vì vậy việc bạn sử dụng cái nào cũng được. 
==> ***SAI***

## 5.2. Giả sử có mười bản ghi của bảng *EMPLOYEES* và mỗi bản ghi chứa giá trị *SALARY* là 100, ngoại trừ một bản ghi có giá trị *null* trong trường *SALARY*. Giá trị nào được trả về sau khi thực hiện câu lệnh sau? (Chọn câu trả lời đúng nhất)
```sql
    SELECT AVG(COALESCE(SALARY,0))::INTEGER
    FROM EMPLOYEES
    GROUP BY SALARY;
```
***==>*** `avg - 0 - 100`
***GIẢI THÍCH:***
Hàm `COALESCE(salary,0)` nó sẽ trả về giá trị *salary* của dòng đó nếu nó khác **NULL**, hoặc 0 nếu gặp dòng có giá trị **NULL**. 
Lúc này ta sẽ có 1 dòng có giá trị là '0' và 9 dòng có giá trị là '100'. 
Thực hiện câu lệnh SQL trên nó sẽ trả về giá trị trung bình của các hàng có cùng giá trị **SALARY** là '0' và giá trị trung bình các hàng có cùng giá trị **SALARY** là '100'. 
==> Kết quả ta sẽ có: 0 - 100

## 5.3. Bảng Arc(x,y) hiện tại có các bộ dữ liệu như sau (hãy lưu ý rằng có sự lặp lại giữa các bộ dữ liệu):

(1,2), (1,2), (2,3), (3,4), (3,4), (4,1), (4,1), (4,1), (4,2).

Hãy tính kết quả sau khi thực hiện truy vấn sau:
```sql
    SELECT a1.x, a2.y, COUNT(*)
    FROM Arc a1, Arc a2
    WHERE a1.y = a2.x
    GROUP BY a1.x, a2.y;
```

==> a1. y = a2.x , thì có những cặp (a1.x, a1.y, a2.y, số lần lặp) <kết tự nhiên thì ko lặp lại cột lần nữa> như (1,2,3,2), (2,3,4,2), (3,4,1,6), (3,4,2,2), (4,1,2,6), (4,2,3,1). 
Lấy theo đề bài:
`(1,3,2), (2,4,2), (3,1,6), (3,2,2), (4,2,6), (4,3,1)`

## 5.4. 
```
Bảng film là một danh sách của tất cả các bộ phim có tiềm năng:

    - film_id (smallint):   Khóa chính thay thế được sử dụng để 
                            nhận dạng từng phim duy nhất trong bảng.
    - title (varchar[255]): Tiêu đề của bộ phim.

Bảng actor liệt kê thông tin của tất cả các diễn viên.

    - actor_id (smallint):  Khóa chính thay thế được sử dụng để 
                            nhận dạng từng diễn viên duy nhất trong bảng.
    - first_name (varchar[50]): Tên của diễn viên.
    - last_name  (varchar[50]): Họ của diễn viên.
    - last_update  (timestamp): Thời gian mà hàng dữ liệu được tạo hoặc cập nhật gần đây nhất.

Bảng film_actor được sử dụng để hỗ trợ mối quan hệ nhiều-nhiều 
giữa bảng film và bảng actor. Đối với mỗi diễn viên trong một bộ phim
nhất định, sẽ có một hàng trong bảng film_actor liệt kê diễn viên và phim.

    - actor_id (smallint):      Khóa ngoại xác định diễn viên.
    - film_id (smallint):       Khóa ngoại xác định phim.
    - last_update (timestamp):  Thời gian mà hàng dữ liệu được tạo hoặc
                                cập nhật gần đây nhất.
```
Cho các bảng *actor*, *film*, *film_actor*, hãy xây dựng bảng kết quả phù hợp với các điều kiện sau: bảng nên có 3 cột là *first_name*, *last_name*, *films*. Bảng này sẽ chỉ có một hàng lưu trữ dữ liệu của diễn viên có nhiều phim nhất.

Nếu hai diễn viên có cùng số lượng phim, hãy sắp xếp dữ liệu theo *first_name*, *last_name* để tìm người phù hợp nhất.

```sql
/*Implement the missing code, denoted by ellipses. 
You may not modify the pre-existing code.*/
SELECT
    a.first_name, a.last_name, COUNT (b.actor_id) films 
FROM
    Actor a
    JOIN
        film_actor b 
        ON 
            a.actor_id = b.actor_id
GROUP BY
    first_name, last_name
ORDER BY
    films DESC
LIMIT 
    1
;
```